from fastapi import FastAPI, Request, File, UploadFile, Response, status
from fastapi.middleware.cors import CORSMiddleware

from tempfile import NamedTemporaryFile
import os
import shutil

from app.config import *
from app.utils import *
import json

from fastapi.responses import StreamingResponse
import asyncio
# to start app cd to project root directory and run:
# uvicorn app.main:app --reload
# reference: https://fastapi.tiangolo.com/#run-it

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Global Variables:
saved_settings = None
transcript = None
transcript_manual_change = False
last_data = None
voicesample_manual_change = False
voicesample = None
is_video = False


def process_file(data, initial_filename):
    # 0. Save video to temp file
    print('0. Save content to temp file')

    path = save_data(data, './' + initial_filename)

    # Save video content to global variable
    global last_data
    with open(path, "rb") as f:
        input_bytes = f.read()
        last_data = input_bytes

    # 1. Get audio from video
    if is_video:
        print('1. Get audio from video')


        audio_path = get_audio_from_video(path, 'temp_audio.wav')
    else:
        audio_path = path

    # 1.5 Convert audio to mp3
    print('1.5 Convert audio to mp3')
    mp3_audio_path = convert_wav_to_mp3(
        audio_path, audio_path.replace('.mp3', '_mp3.mp3').replace('.wav', '.mp3'))
    
    global voicesample_manual_change
    global voicesample
    if voicesample_manual_change:
        print('Using voicesample from global variable')
        voicesample_audio_path = convert_wav_to_mp3(
            voicesample, voicesample.replace('.mp3', '_mp3.mp3').replace('.wav', '.mp3'))
        # voicesample_manual_change = False
    else:
        voicesample_audio_path = None

    # 2. Get text from audio
    print('2. Get text from audio')
    global transcript_manual_change
    if not transcript_manual_change:
        global transcript
        transcript = get_text_from_audio(mp3_audio_path)
        transcript = add_puctuation(transcript)
    else: 
        print('Using transcript from global variable')
        transcript_manual_change = False
    print(transcript)

    # 3. Clone voice (if needed) from audio
    print('3. Clone voice (if needed) from audio')
    if voicesample_audio_path is not None:
        voice = clone_voice(voicesample_audio_path)
    else:
        voice = clone_voice(mp3_audio_path)

    # 4. Generate new audio from text (and cloned voice)
    print('4. Generate new audio from text (and cloned voice)')
    chosen_language = None
    if (saved_settings is not None):
        if saved_settings["language"].lower() == "no translation":
            chosen_language = None
        else:
            chosen_language = saved_settings["language"]

    print(chosen_language)
    print(saved_settings)

    if chosen_language is not None:
        transcript = translate_text(transcript, chosen_language)
        print(transcript)

    generated_audio_path = generate_audio(
        transcript, voice, 'temp_generated.wav')

    if is_video:
        # 5. Merge new audio with video
        print('5. Merge new audio with video')
        final_path = merge_audio_with_video(
            generated_audio_path, path, 'temp_final_video.mp4')

        # optional: add subtitles
        if (saved_settings is not None and saved_settings["doSubtitles"] is True):
            print("Add subtitles")
            final_path_with_sub = 'sub_' + final_path
            subtitled_video = add_autogenerated_subtitles(
                final_path, generated_audio_path)
            subtitled_video.write_videofile(
                final_path_with_sub, fps=subtitled_video.fps)
        else:
            final_path_with_sub = None
    else:
        final_path = generated_audio_path
        final_path_with_sub = None


    # 5.5 Convert content to bytes
    print('5.5 Convert content to bytes')
    if final_path_with_sub is not None:
        with open(final_path_with_sub, "rb") as f:
            final_bytes = f.read()
    else:
        with open(final_path, "rb") as f:
            final_bytes = f.read()

    # 6. Clean the temp files
    print('6. Clean the temp files')

    os.remove(audio_path)
    os.remove(mp3_audio_path)
    os.remove(generated_audio_path)
    if is_video:
        os.remove(path)
        os.remove(final_path)
        if final_path_with_sub is not None:
            os.remove(final_path_with_sub)
    voice.delete()

    # 7. Output edited content
    print('7. Output edited content')

    return final_bytes


@app.post("/video")
async def read_item(video: UploadFile):
    global is_video
    is_video = True

    print("Video processing:", video.filename)
    data = await video.read()

    final_video_bytes = await process_file(data, video.filename)
    return Response(content=final_video_bytes, media_type="video/wav")


@app.post("/audio")
async def read_item(audio: UploadFile):
    global is_video
    is_video = False

    print("Audio processing:", audio.filename)
    data = await audio.read()

    final_audio_bytes = process_file(data, audio.filename)

    return Response(content=final_audio_bytes, media_type="audio/mp3")

@app.post("/settings")
async def receive_settings(request: Request):
    data = await request.json()
    global saved_settings
    saved_settings = data
    print(data)

    return {"message": data}


@app.post("/voicesample")
async def read_item(voiceSample: UploadFile):
    print("Got voice sample")
    data = await voiceSample.read()

    global voicesample_manual_change
    global voicesample
    voicesample_manual_change = True
    voicesample = voiceSample.filename

    with open(voicesample, 'wb') as f:
        f.write(data)

    return {"filenames": voicesample}


@app.get("/textedition")
async def get_text():
    global transcript
    print(transcript)
    print(transcript_manual_change)
    return {"text": transcript}


@app.post("/textedition")
async def post_text(request: Request):
    data = await request.json()
    print('Text edition:', data)
    global transcript_manual_change
    global transcript
    transcript_manual_change = True
    transcript = data

    global last_data
    global is_video
    final_bytes = process_file(last_data, 'temp.mp4' if is_video else 'temp.mp3')
    return Response(content=final_bytes)

